// ESNext에서 추가되거나, 변경된 문법 4
/**
 * 자료구조에서 정보(데이터) 추출 방법          << 1
 * - 자료구조 : 객체 {}, 배열 []
 * - Destructuring assignment(구조분해할당)
 * 
 * 객체 리터럴(타입 1번)의 기능 확장           << 2
 * 
 * 스프레드 연산자 ( ... )   << 점이3개        << 3
 */

// 객체 내에서 정보 추출 -> 객체 구조 분해
// 전달된 데이터가 json or 객체 => 객체 구조 분해 => 원하는 값 추출
let data = {
    s1:'서면역',
    s2:'부전역',
    s3:'부산역',
    s4:['사상역', '김해공항역', '센텀시티역'] // Array 객체
}
console.log( data )
// 값 추출
console.log( data.s2 )

// 객체 구조 분해, 데이터는 다 전달 받았는데 그중 일부만 사용하고 싶다면? s2,s3
// s2:bu => 변수명을 변경하고 싶다면
let { s2:bu, s3, s5, s4  } = data // data객체에서 s2/s3와 일치하는 맴버값을 추출

// 맴버로 없는 이름을 사용할 경우 => 변수는 생기나 값은 undefined
console.log( `s3 => ${s3}`, s5, s4, bu)

// 추출한 변수값을 수정하면 원본에 영향을 받는가?
s3 = '변경' // 원본에 영향을 미치지 않는다 => 사본이다(카피돼서 다른데 복사된다)
console.log("값을 수정해도 수정이 안된다? =>", s3, data )

// ==========================================================================
// ** 배열(순서가 존재, index사용(0,1,2,...)) 구조 분해
// [ '사상역', '김해공항역', '센텀시티역' ]
console.log("배열의 모습은?", s4, s4[0] )

// 쓰고 싶은 변수명을 사용하여 추출 -> * 배열은 순서가 중요
// 추출하지 않는 자리는 ,로 대체, 활용 빈도가 높지는 않다.
let [ , ,abcd] = s4
console.log(abcd)

// ==========================================================================
// ** 객체 리터럴의 표현 확장
let w1 = 90
let age1 = 100
const getW = () => {
    console.log('hi')
}

// 전역변수의 값(변수들)을 객체 생성시 데이터로 사용 가능하다.
// 벽에 붙어있는 애들은 전역변수, 중괄화 안에 있는 건 지역변수이다.
let obj = {
    w:w1,
    age:age1
}
let obj2 = {
    w1,
    age1,
    getW, // 맴버 함수
    // 함수를 직접 맴버로 넣는다면?
    info () {
        console.log( 'info', w1, age1)
    }
}
console.log( obj.w, obj2.w1 )
obj2.getW()
obj2.info()

// ==========================================================================
// **스프레드 연산자 ( ... 변수 )
var a1 = ['콜라', '물', '사이다']
var a2 = ['밥', '햄버거']
console.log( a1 )     // [ '콜라', '물', '사이다' ]
console.log( ...a1 )  // 콜라 물 사이다         << 값들이 모두 추출된다 => 카피(얕은, 깊은), 편의성 활용

// a1 배열과 a2 배열을 합치고, '김치'라는 값까지 합쳐서 새로운 배열을 만드시오.
// 결과물 => [ a1 배열, a2 배열, '김치' ]
var a3 = [ ...a1, ...a2, '김치' ]
console.log( "배열 합치기 =>", a3 )


// 객체 copy
const obj10 = {
    a:10,
    b:20
}
const obj11 = {
    a:11,
    c:30
}
// 여러 객체를 카피해서 새로운 객체를 만들 때, 중복되는 값이 있다면 뒤에것으로 대체된다.
console.log( "객체 합치기 => ", { ...obj10, ...obj11 } )


// 함수 인자로 활용 -> *가변인자(...args : 값을 보내는 족족 다 출력된다)
function test(...args) {
    console.log( args )
    // 배열 구조 분해 + 스프레드 연산(나머지 모두다 카피)
    var [ d1, ...remain ] = args 
    // d1 => '콜라', remaind => ['물', '사이다']
    console.log( '1. ', d1, remain)
    
    var [ d2, ...end ] = remain.reverse() //remain은 반대로
    // d2 => '사이다', end => ['물'], remaind => ['사이다', '물']
    console.log( '2. ', d2, end, remain)
}
test( '콜라', '물', '사이다' )
test( '콜라', '물', '사이다', 10, 11, 12 )

// 객체 구조분해를 함수의 인자로 표현 -> << 객체를 넣으면 바로 분해해서 사용하겠다? >>
function test2( { s1 }) { 
    console.log( s1 )
}
test2( data )

// 배열 구조 분해를 함수의 파라미터에 대입 -> 잘 사용되지는 않는다
function test3( [s1, , ] ) { // 첫번째꺼만 받고, 나머지는 안받겠다
    console.log( s1 )
}
test3( a1 )